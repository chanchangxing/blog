<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  
  <title>RecyclerView源码解析1 | chanchangxing</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="RecyclerView渲染流程RecyclerView也是一个View，也要遵循View的三个步骤。onMeasure、onLayout、onDraw. 
那么就来照着这个顺序来解剖RecyclerView。 
解剖依照的项目是google的android sample 
onMeasure12345678910111213141516class RecyclerView &amp;#123;    @">
<meta property="og:type" content="article">
<meta property="og:title" content="RecyclerView源码解析1">
<meta property="og:url" content="https://chanchangxing.me/2019/04/30/RecyclerView源码解析1/index.html">
<meta property="og:site_name" content="chanchangxing">
<meta property="og:description" content="RecyclerView渲染流程RecyclerView也是一个View，也要遵循View的三个步骤。onMeasure、onLayout、onDraw. 
那么就来照着这个顺序来解剖RecyclerView。 
解剖依照的项目是google的android sample 
onMeasure12345678910111213141516class RecyclerView &amp;#123;    @">
<meta property="og:updated_time" content="2019-04-30T07:24:23.260Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RecyclerView源码解析1">
<meta name="twitter:description" content="RecyclerView渲染流程RecyclerView也是一个View，也要遵循View的三个步骤。onMeasure、onLayout、onDraw. 
那么就来照着这个顺序来解剖RecyclerView。 
解剖依照的项目是google的android sample 
onMeasure12345678910111213141516class RecyclerView &amp;#123;    @">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/typing.css">
  <link rel="stylesheet" href="/css/donate.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css">
  
</head>

  
    
      <body class="dark">
    
  
      <div id="container" class="container">
        <article id="post-RecyclerView源码解析1" class="article article-type-post" itemscope itemprop="blogPost">
  <header id="header" class="header">
  <nav class="mobile-nav">
    <h1 class="nickname">铲昶行的智障空间</h1>
    <ul class="mobile-nav-menu">
      <label for="mobile-menu-toggle"><a>&#9776; Menu</a></label>
      <input type="checkbox" id="mobile-menu-toggle"/>
      <ul class="mobile-nav-link">
        
        <a href="/">首页</a>
        
        <a href="/archives">文章</a>
        
        <a href="/tags/android">Android</a>
        
        <a href="/tags/reactnative/">ReactNative</a>
        
        <a href="/tags/leetcode">Leetcode</a>
        
        <a href="/tags/面试总结">面试总结</a>
        
      </ul>
    </ul>
  </nav>
	
		<nav id="main-nav" class="main-nav nav-left">
	
	
	  <a class="main-nav-link" href="/">首页</a>
	
	  <a class="main-nav-link" href="/archives">文章</a>
	
	  <a class="main-nav-link" href="/tags/android">Android</a>
	
	  <a class="main-nav-link" href="/tags/reactnative/">ReactNative</a>
	
	  <a class="main-nav-link" href="/tags/leetcode">Leetcode</a>
	
	  <a class="main-nav-link" href="/tags/面试总结">面试总结</a>
	
  </nav>
</header>

  <hr/>
  <div class="article-inner">
    

    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      RecyclerView源码解析1
    </h1>
  

      </header>
    
    <div class="article-entry typo" itemprop="articleBody">
      
        <h4 id="RecyclerView渲染流程"><a href="#RecyclerView渲染流程" class="headerlink" title="RecyclerView渲染流程"></a>RecyclerView渲染流程</h4><p>RecyclerView也是一个View，也要遵循View的三个步骤。<code>onMeasure</code>、<code>onLayout</code>、<code>onDraw</code>. </p>
<p>那么就来照着这个顺序来解剖RecyclerView。 </p>
<p>解剖依照的项目是google的<a href="https://github.com/googlesamples/android-RecyclerView/#readme" target="_blank" rel="external">android sample</a> </p>
<h5 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecyclerView</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span> </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthSpec, <span class="keyword">int</span> heightSpec)</span> </span>&#123; </div><div class="line">    		<span class="comment">//... </span></div><div class="line">        <span class="keyword">if</span> (mLayout.mAutoMeasure) &#123; </div><div class="line">        		<span class="comment">//... </span></div><div class="line">        &#125; <span class="keyword">else</span> &#123; </div><div class="line">            <span class="keyword">if</span> (mHasFixedSize) &#123; </div><div class="line">            <span class="comment">// 默认情况下，Recycler的onMeasure直接走了 </span></div><div class="line">            <span class="comment">// LayoutManager的onMeasure方法。 </span></div><div class="line">            mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec); </div><div class="line">            <span class="keyword">return</span>; </div><div class="line">            &#125; </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecyclerView</span>.<span class="title">LayoutManager</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(Recycler recycler, State state, <span class="keyword">int</span> widthSpec, <span class="keyword">int</span> heightSpec)</span> </span>&#123; </div><div class="line">        <span class="comment">// 这里又再次调用Recycler的defaultOnMeasure方法。 </span></div><div class="line">        <span class="comment">// 真的不清楚把LayoutManager放到RecyclerView类里是个什么操作. </span></div><div class="line">        mRecyclerView.defaultOnMeasure(widthSpec, heightSpec); </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecyclerView</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">defaultOnMeasure</span><span class="params">(<span class="keyword">int</span> widthSpec, <span class="keyword">int</span> heightSpec)</span> </span>&#123; </div><div class="line">    <span class="comment">// calling LayoutManager here is not pretty but that API is already public and it is 				// better </span></div><div class="line">    <span class="comment">// than creating another method since this is internal. </span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> width = LayoutManager.chooseSize(widthSpec, </div><div class="line">    getPaddingLeft() + getPaddingRight(), </div><div class="line">    ViewCompat.getMinimumWidth(<span class="keyword">this</span>)); </div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> height = LayoutManager.chooseSize(heightSpec, </div><div class="line">    getPaddingTop() + getPaddingBottom(), </div><div class="line">    ViewCompat.getMinimumHeight(<span class="keyword">this</span>)); </div><div class="line">    setMeasuredDimension(width, height); </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout"></a>onLayout</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecyclerView</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span> </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123; </div><div class="line">        <span class="comment">//... </span></div><div class="line">        dispatchLayout(); </div><div class="line">        <span class="comment">//... </span></div><div class="line">        mFirstLayoutComplete = <span class="keyword">true</span>; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecyclerView</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dispatchLayout</span><span class="params">()</span> </span>&#123; </div><div class="line">        <span class="comment">//... </span></div><div class="line">        mState.mIsMeasuring = <span class="keyword">false</span>; </div><div class="line">        <span class="comment">// 在初始化RecyclerView的时候，mState.mLayoutStep 等于 State.STEP_START </span></div><div class="line">        <span class="keyword">if</span> (mState.mLayoutStep == State.STEP_START) &#123; </div><div class="line">            <span class="comment">// 这里Layout有三个步骤，先来看step1. </span></div><div class="line">            dispatchLayoutStep1(); </div><div class="line">            mLayout.setExactMeasureSpecsFrom(<span class="keyword">this</span>); </div><div class="line">            <span class="comment">// 这里Layout完成了step2。ViewHolder放入RecyclerView的过程. </span></div><div class="line">            dispatchLayoutStep2(); </div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mAdapterHelper.hasUpdates() || mLayout.getWidth() != getWidth() || </div><div class="line">        mLayout.getHeight() != getHeight()) &#123; </div><div class="line">            <span class="comment">//... </span></div><div class="line">        &#125; <span class="keyword">else</span> &#123; </div><div class="line">            <span class="comment">//... </span></div><div class="line">        &#125; </div><div class="line">        <span class="comment">// step3中间有主要的流程，是关于缓存的，但是我们还没有走到缓存 </span></div><div class="line">        <span class="comment">// 所以我们就不看了 </span></div><div class="line">        dispatchLayoutStep3(); </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// step1</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecyclerView</span> </span>&#123;</div><div class="line">    <span class="comment">/** </span></div><div class="line">      * The first step of a layout where we; </div><div class="line">      * - process adapter updates(处理Adapter更新) </div><div class="line">      * - decide which animation should run(决定要跑哪个动画) </div><div class="line">      * - save information about current views(对当前view保存信息) </div><div class="line">      * - If necessary, run predictive layout and save its information(如果需要，运行预先的页面并保存信息) </div><div class="line">      * </div><div class="line">      * 我想说，step1唯一对我们分析代码有效的就只是赋值了。 </div><div class="line">    */ </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchLayoutStep1</span><span class="params">()</span> </span>&#123; </div><div class="line">        <span class="comment">//... </span></div><div class="line">        mState.mIsMeasuring = <span class="keyword">false</span>; </div><div class="line">        <span class="comment">//... </span></div><div class="line">        mState.mTrackOldChangeHolders = mState.mRunSimpleAnimations &amp;&amp; mItemsChanged; </div><div class="line">        mItemsAddedOrRemoved = mItemsChanged = <span class="keyword">false</span>; </div><div class="line">        mState.mInPreLayout = mState.mRunPredictiveAnimations; </div><div class="line">        mState.mItemCount = mAdapter.getItemCount(); </div><div class="line">        <span class="comment">//... </span></div><div class="line">        mState.mLayoutStep = State.STEP_LAYOUT; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecyclerView</span> </span>&#123;</div><div class="line">    <span class="comment">/** </span></div><div class="line">    	* The second layout step where we do the actual layout of the views for the final state. </div><div class="line">    	* This step might be run multiple times if necessary (e.g. measure). </div><div class="line">    	*/ </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchLayoutStep2</span><span class="params">()</span> </span>&#123; </div><div class="line">    <span class="comment">//... </span></div><div class="line">    mState.mItemCount = mAdapter.getItemCount(); </div><div class="line">    mState.mDeletedInvisibleItemCountSincePreviousLayout = <span class="number">0</span>; </div><div class="line">    <span class="comment">// Step 2: Run layout </span></div><div class="line">    mState.mInPreLayout = <span class="keyword">false</span>; </div><div class="line">    <span class="comment">// 在step1和前面的操作，将mState的数据已经处理好， </span></div><div class="line">    <span class="comment">// 之后就进入最关键的onLayoutChildren. </span></div><div class="line">    mLayout.onLayoutChildren(mRecycler, mState); </div><div class="line">    <span class="comment">// 这里onLayoutChildren已经分析完，完成了将ViewHolder放入RecyclerView的过程 </span></div><div class="line">    mState.mStructureChanged = <span class="keyword">false</span>; </div><div class="line">    mPendingSavedState = <span class="keyword">null</span>; </div><div class="line">    <span class="comment">// onLayoutChildren may have caused client code to disable item animations; re-check </span></div><div class="line">    mState.mRunSimpleAnimations = mState.mRunSimpleAnimations &amp;&amp; mItemAnimator != <span class="keyword">null</span>; </div><div class="line">    mState.mLayoutStep = State.STEP_ANIMATIONS; </div><div class="line">    <span class="comment">//... </span></div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearLayoutManager</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLayoutChildren</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state)</span> </span>&#123; </div><div class="line">    <span class="comment">// layout algorithm: </span></div><div class="line">    <span class="comment">// 1) by checking children and other variables, find an anchor coordinate and an anchor </span></div><div class="line">    <span class="comment">// item position. </span></div><div class="line">    <span class="comment">// 通过检查子项和其他变量，找到锚点坐标和锚点项目位置 </span></div><div class="line">    <span class="comment">// 2) fill towards start, stacking from bottom </span></div><div class="line">    <span class="comment">// 从下往上填充，从底部开始堆 </span></div><div class="line">    <span class="comment">// 3) fill towards end, stacking from top </span></div><div class="line">    <span class="comment">// 从上往下填充，从顶部开始堆 </span></div><div class="line">    <span class="comment">// 4) scroll to fulfill requirements like stack from bottom. </span></div><div class="line">    <span class="comment">// create layout state </span></div><div class="line">    <span class="comment">// 滚动以满足从底部堆栈的要求。创建布局状态 </span></div><div class="line"></div><div class="line">    <span class="comment">//...  </span></div><div class="line"></div><div class="line">    <span class="comment">//创建一个LayoutState </span></div><div class="line">    ensureLayoutState(); </div><div class="line">    mLayoutState.mRecycle = <span class="keyword">false</span>; </div><div class="line">    <span class="comment">//... </span></div><div class="line">    <span class="keyword">if</span> (!mAnchorInfo.mValid || mPendingScrollPosition != NO_POSITION || </div><div class="line">    mPendingSavedState != <span class="keyword">null</span>) &#123; </div><div class="line">        mAnchorInfo.reset(); </div><div class="line">        mAnchorInfo.mLayoutFromEnd = mShouldReverseLayout ^ mStackFromEnd; </div><div class="line">        <span class="comment">// calculate anchor position and coordinate </span></div><div class="line">        updateAnchorInfoForLayout(recycler, state, mAnchorInfo); </div><div class="line">        mAnchorInfo.mValid = <span class="keyword">true</span>; </div><div class="line">    &#125; </div><div class="line"></div><div class="line">    <span class="comment">//... </span></div><div class="line"></div><div class="line">    <span class="comment">// LLM may decide to layout items for "extra" pixels to account for scrolling target, </span></div><div class="line">    <span class="comment">// caching or predictive animations. </span></div><div class="line">    <span class="keyword">int</span> extraForStart; </div><div class="line">    <span class="keyword">int</span> extraForEnd; </div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> extra = getExtraLayoutSpace(state); </div><div class="line"></div><div class="line">    <span class="comment">// If the previous scroll delta was less than zero, the extra space should be laid out </span></div><div class="line">    <span class="comment">// at the start. Otherwise, it should be at the end. </span></div><div class="line">    <span class="keyword">if</span> (mLayoutState.mLastScrollDelta &gt;= <span class="number">0</span>) &#123; </div><div class="line">        extraForEnd = extra; </div><div class="line">        extraForStart = <span class="number">0</span>; </div><div class="line">    &#125; <span class="keyword">else</span> &#123; </div><div class="line">        extraForStart = extra; </div><div class="line">        extraForEnd = <span class="number">0</span>; </div><div class="line">    &#125; </div><div class="line"></div><div class="line">    extraForStart += mOrientationHelper.getStartAfterPadding(); </div><div class="line">    extraForEnd += mOrientationHelper.getEndPadding(); </div><div class="line"></div><div class="line">    <span class="comment">//... </span></div><div class="line"></div><div class="line">    <span class="keyword">int</span> startOffset; </div><div class="line">    <span class="keyword">int</span> endOffset; </div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> firstLayoutDirection; </div><div class="line"></div><div class="line">    <span class="keyword">if</span> (mAnchorInfo.mLayoutFromEnd) &#123; </div><div class="line">        <span class="comment">//... </span></div><div class="line">    &#125; <span class="keyword">else</span> &#123; </div><div class="line">        firstLayoutDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_HEAD : </div><div class="line">    LayoutState.ITEM_DIRECTION_TAIL; </div><div class="line">    &#125; </div><div class="line"></div><div class="line">    <span class="comment">//... </span></div><div class="line"></div><div class="line">    mLayoutState.mInfinite = resolveIsInfinite(); </div><div class="line">    mLayoutState.mIsPreLayout = state.isPreLayout(); </div><div class="line">    <span class="keyword">if</span> (mAnchorInfo.mLayoutFromEnd) &#123; </div><div class="line">        <span class="comment">//... </span></div><div class="line">    &#125; <span class="keyword">else</span> &#123; </div><div class="line">        <span class="comment">// fill towards end </span></div><div class="line">        <span class="comment">// 从上到下推。 </span></div><div class="line">        updateLayoutStateToFillEnd(mAnchorInfo); </div><div class="line">        mLayoutState.mExtra = extraForEnd; </div><div class="line">        <span class="comment">// 这个方法是重中之重，必须要走进方法看一看。 </span></div><div class="line">        <span class="comment">// 到这里的时候，RecyclerView已经有两个状态类。 </span></div><div class="line">        <span class="comment">// LayoutState、RecyclerView.State </span></div><div class="line">        fill(recycler, mLayoutState, state, <span class="keyword">false</span>); </div><div class="line">        <span class="comment">// 这里fill分析完了，他完成了viewholder放入 // recyclerView的操作. </span></div><div class="line">        endOffset = mLayoutState.mOffset; </div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> lastElement = mLayoutState.mCurrentPosition; </div><div class="line">        <span class="keyword">if</span> (mLayoutState.mAvailable &gt; <span class="number">0</span>) &#123; </div><div class="line">            extraForStart += mLayoutState.mAvailable; </div><div class="line">        &#125; </div><div class="line">        <span class="comment">// 这里又从下到上再来一次，因为我们现在是初始化进行，所以都 // 是从上到下把所有的item都渲染好了，就不用再去走从下到上的 </span></div><div class="line">        <span class="comment">// fill了。 </span></div><div class="line">        updateLayoutStateToFillStart(mAnchorInfo); </div><div class="line">        mLayoutState.mExtra = extraForStart; </div><div class="line">        mLayoutState.mCurrentPosition += mLayoutState.mItemDirection; </div><div class="line">        fill(recycler, mLayoutState, state, <span class="keyword">false</span>); </div><div class="line">        startOffset = mLayoutState.mOffset; </div><div class="line">        <span class="comment">// ... </span></div><div class="line">    &#125; </div><div class="line"></div><div class="line">    <span class="comment">// ... </span></div><div class="line">    mLastStackFromEnd = mStackFromEnd; </div><div class="line">    <span class="comment">// ... </span></div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecyclerView</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fill</span><span class="params">(RecyclerView.Recycler recycler, LayoutState layoutState, RecyclerView.State state, <span class="keyword">boolean</span> stopOnFocusable)</span> </span>&#123; </div><div class="line">        <span class="comment">// max offset we should set is mFastScroll + available </span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> start = layoutState.mAvailable; </div><div class="line">        <span class="comment">//... </span></div><div class="line">        <span class="keyword">int</span> remainingSpace = layoutState.mAvailable + layoutState.mExtra; </div><div class="line">        LayoutChunkResult layoutChunkResult = <span class="keyword">new</span> LayoutChunkResult(); </div><div class="line">        <span class="keyword">while</span> ((layoutState.mInfinite || remainingSpace &gt; <span class="number">0</span>) &amp;&amp; layoutState.hasMore(state)) &#123; </div><div class="line">            <span class="comment">// layoutChunk方法很关键 </span></div><div class="line">            <span class="comment">// 这里我们要进入layoutChunk方法看看 </span></div><div class="line">            layoutChunk(recycler, state, layoutState, layoutChunkResult); </div><div class="line">            <span class="comment">// 这里是layoutChunk已经分析完了，得到的结果就是拿到了 </span></div><div class="line">            <span class="comment">// adapter的view，并加入到了RecyclerView，并且已经做了 </span></div><div class="line">            <span class="comment">// measure和layout </span></div><div class="line">            <span class="comment">// ... </span></div><div class="line">            layoutState.mOffset += layoutChunkResult.mConsumed * layoutState.mLayoutDirection; </div><div class="line">            <span class="comment">/** </span></div><div class="line">            * Consume the available space if: </div><div class="line">            * * layoutChunk did not request to be ignored </div><div class="line">            * * OR we are laying out scrap children </div><div class="line">            * * OR we are not doing pre-layout </div><div class="line">            */ </div><div class="line">            <span class="comment">// 这里我们计算还有多少空间可以用。 </span></div><div class="line">            <span class="keyword">if</span> (!layoutChunkResult.mIgnoreConsumed || mLayoutState.mScrapList != <span class="keyword">null</span> </div><div class="line">            || !state.isPreLayout()) &#123; </div><div class="line">                layoutState.mAvailable -= layoutChunkResult.mConsumed; </div><div class="line">                <span class="comment">// we keep a separate remaining space because mAvailable is important for recycling </span></div><div class="line">                remainingSpace -= layoutChunkResult.mConsumed; </div><div class="line">            &#125; </div><div class="line">            <span class="comment">// 这里有一段mScrollingOffset的代码，但是这里没有用到。 </span></div><div class="line">            <span class="comment">// 因为mScrollingOffset 一直等于 Integer.MIN_VALUE </span></div><div class="line">            <span class="comment">// ... </span></div><div class="line">        &#125; </div><div class="line">        <span class="comment">// ... </span></div><div class="line"></div><div class="line">        <span class="keyword">return</span> start - layoutState.mAvailable; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearLayoutManager</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">layoutChunk</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state, LayoutState layoutState, LayoutChunkResult result)</span> </span>&#123; </div><div class="line">        <span class="comment">// layoutState.next方法其实就是这个方法重要的原因 </span></div><div class="line">        View view = layoutState.next(recycler); </div><div class="line">        <span class="comment">// 这里 layoutState.next已经分析完，得到ViewHolder的view </span></div><div class="line"></div><div class="line">        <span class="comment">// ... </span></div><div class="line"></div><div class="line">        LayoutParams params = (LayoutParams) view.getLayoutParams(); </div><div class="line">        <span class="keyword">if</span> (layoutState.mScrapList == <span class="keyword">null</span>) &#123; </div><div class="line">            <span class="keyword">if</span> (mShouldReverseLayout == (layoutState.mLayoutDirection </div><div class="line">            == LayoutState.LAYOUT_START)) &#123; </div><div class="line">                <span class="comment">// 这里addView做了两个操作 </span></div><div class="line">                <span class="comment">// 将这个view放入ChildHelper的bucket中 </span></div><div class="line">                <span class="comment">// 将view加入到RecyclerView中 </span></div><div class="line">                addView(view); </div><div class="line">            &#125; <span class="keyword">else</span> &#123; </div><div class="line">                <span class="comment">// 这里的操作和上面的addView差不多，只是顺序不一样 </span></div><div class="line">                addView(view, <span class="number">0</span>); </div><div class="line">            &#125; </div><div class="line">        &#125; <span class="keyword">else</span> &#123; </div><div class="line">            <span class="comment">// ... </span></div><div class="line">        &#125; </div><div class="line">        <span class="comment">// 后面有一系列的操作，各种计算，都是为了measuer和layout我们得 </span></div><div class="line">        <span class="comment">// 到的ViewHolder的view。 </span></div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearLayoutManager</span>.<span class="title">LayoutState</span> </span>&#123; </div><div class="line">    <span class="function">View <span class="title">next</span><span class="params">(RecyclerView.Recycler recycler)</span> </span>&#123; </div><div class="line">        <span class="comment">//... </span></div><div class="line"></div><div class="line">        <span class="comment">// 这里是从Recycler中拿出相应的ViewHolder </span></div><div class="line">        <span class="comment">// Recycler就是RecyclerView的管理类 </span></div><div class="line">        <span class="keyword">final</span> View view = recycler.getViewForPosition(mCurrentPosition); </div><div class="line">        mCurrentPosition += mItemDirection; </div><div class="line">        <span class="comment">// 从上面的方法得到要加入的view，并返回 </span></div><div class="line">        <span class="keyword">return</span> view; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Recycler</span> </span>&#123; </div><div class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">getViewForPosition</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123; </div><div class="line">        <span class="comment">// 这个方法直接调用的是下面的方法。 </span></div><div class="line">        <span class="keyword">return</span> getViewForPosition(position, <span class="keyword">false</span>); </div><div class="line">    &#125; </div><div class="line">		<span class="function">View <span class="title">getViewForPosition</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">boolean</span> dryRun)</span> </span>&#123; </div><div class="line">        <span class="comment">//...</span></div><div class="line">        <span class="keyword">boolean</span> fromScrap = <span class="keyword">false</span>; </div><div class="line">        ViewHolder holder = <span class="keyword">null</span>; </div><div class="line">        <span class="comment">// 0) If there is a changed scrap, try to find from there </span></div><div class="line">        <span class="comment">//... </span></div><div class="line">        <span class="comment">// 1) Find from scrap by position </span></div><div class="line">        <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123; </div><div class="line">            <span class="comment">// 这里是从mAttachScrap列表中寻找缓存 </span></div><div class="line">            <span class="comment">// 通过这个viewHolder的position。 </span></div><div class="line">            holder = getScrapViewForPosition(position, INVALID_TYPE, dryRun); </div><div class="line">            <span class="comment">// 因为在初始化的时候，并没有缓存。 </span></div><div class="line">        &#125; </div><div class="line"></div><div class="line">        <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123; </div><div class="line">        		<span class="keyword">final</span> <span class="keyword">int</span> offsetPosition = mAdapterHelper.findPositionOffset(position); </div><div class="line">        		<span class="comment">//... </span></div><div class="line">        		<span class="keyword">final</span> <span class="keyword">int</span> type = mAdapter.getItemViewType(offsetPosition); </div><div class="line">        		<span class="comment">// 2) Find from scrap via stable ids, if exists </span></div><div class="line">        		<span class="keyword">if</span> (mAdapter.hasStableIds()) &#123; </div><div class="line">        				<span class="comment">// Adapter没有设置StableIds，所以不会走这里的逻辑 </span></div><div class="line">        		&#125; </div><div class="line"></div><div class="line">            <span class="keyword">if</span> (holder == <span class="keyword">null</span> &amp;&amp; mViewCacheExtension != <span class="keyword">null</span>) &#123; </div><div class="line">            		<span class="comment">// 这里的逻辑我们也不会走 </span></div><div class="line">            		<span class="comment">// mViewCacheExtension是客户端程序员自己设置的缓存机制，所以这里也不会走 </span></div><div class="line">            &#125; </div><div class="line"></div><div class="line">        		<span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123; <span class="comment">// fallback to recycler </span></div><div class="line">        				<span class="comment">// try recycler. </span></div><div class="line">        				<span class="comment">// Head to the shared pool. </span></div><div class="line">        				<span class="comment">// ... </span></div><div class="line">        				<span class="comment">// 这里通过viewType去RecyclerViewPool来找相同的viewType的ViewHolder </span></div><div class="line">        				holder = getRecycledViewPool().getRecycledView(type); </div><div class="line">        				<span class="comment">// 但是其实RecyclerPool并没有缓存 </span></div><div class="line">        		&#125; </div><div class="line"></div><div class="line">            <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123; </div><div class="line">                <span class="comment">// 走到这里说明已经没有缓存了，直接重新构建 // ViewHolder的生命周期了 </span></div><div class="line">                holder = mAdapter.createViewHolder(RecyclerView.<span class="keyword">this</span>, type); </div><div class="line">                <span class="comment">//... </span></div><div class="line">            &#125; </div><div class="line">        &#125; </div><div class="line"></div><div class="line">        <span class="comment">//... </span></div><div class="line">        <span class="keyword">boolean</span> bound = <span class="keyword">false</span>; </div><div class="line">        <span class="keyword">if</span> (mState.isPreLayout() &amp;&amp; holder.isBound()) &#123; </div><div class="line">        		<span class="comment">// ... </span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) &#123; </div><div class="line">        		<span class="comment">// ... </span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> offsetPosition = mAdapterHelper.findPositionOffset(position); </div><div class="line">            holder.mOwnerRecyclerView = RecyclerView.<span class="keyword">this</span>; </div><div class="line">            <span class="comment">// 这里最重要的就是走了adapter的bindViewHolder方法 </span></div><div class="line">            mAdapter.bindViewHolder(holder, offsetPosition); </div><div class="line">            <span class="comment">// ... </span></div><div class="line">            bound = <span class="keyword">true</span>; </div><div class="line">            <span class="comment">// ... </span></div><div class="line">        &#125; </div><div class="line"></div><div class="line">        <span class="comment">// 这里的操作已经无伤大雅了。略过 </span></div><div class="line">        <span class="keyword">return</span> holder.itemView; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="onDraw"><a href="#onDraw" class="headerlink" title="onDraw"></a>onDraw</h5><p><code>RecyclerView</code>的<code>onDraw()</code>方法主要是用来渲染<code>ItemDecoration()</code>，而<code>onDraw()</code>方法里会调用<code>onDrawChild()</code>，对每个ViewHolder进行渲染，所以没啥好解释的。 </p>

      
      
    </div>
    <footer class="article-footer">
      <ul class="article-meta">
        <li>
          <span class="label">Published Date:</span>
          <a href="/2019/04/30/RecyclerView源码解析1/" class="article-date">
  <time datetime="2019-04-30T06:46:22.000Z" itemprop="datePublished">2019-04-30</time>
</a>

        </li>
        
        
        <hr/>
      </ul>
    </footer>
  </div>
  
    
<nav id="article-nav" class="article-nav">
  
    <span id="article-nav-newer" class="article-nav-link-wrap newer"></span>
  
  
    <a href="/2019/04/10/单词搜索/" id="article-nav-older" class="article-nav-link-wrap older">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">单词搜索</div>
    </a>
  
</nav>


  
</article>










      </div>
      
    <footer id="footer" class="post-footer footer">
      
        <ul class="footer-links">
          
            <li><a href="/archives/"><span class="fa fa-book"></span></a></li>
          
            <li><a href="https://github.com/chanchangxing"><span class="fa fa-globe"></span></a></li>
          
        </ul>
	    
      <hr/>
      <div id="footerContent" class="footer-content">
        <p>这篇写完就删站</p>


      </div>
    </footer>

      







<script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>


  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>


<script src="/js/typing.js"></script>
<!--[if lt IE 9]><script src="https://cdn.jsdelivr.net/npm/html5shiv@3/dist/html5shiv.min.js"></script><![endif]-->







    </div>
  </body>
</html>
