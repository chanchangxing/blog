<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  
  <title>RecyclerView源码解析 | chanchangxing</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="RecyclerView渲染流程和获取缓存RecyclerView也是一个View，也要遵循View的三个步骤。onMeasure、onLayout、onDraw. 
那么就来照着这个顺序来解剖RecyclerView。 
解剖依照的项目是google的android sample 
onLayout在RecyclerView中，子View都是在LayoutManger中进行计算大小，布局的。所以">
<meta property="og:type" content="article">
<meta property="og:title" content="RecyclerView源码解析">
<meta property="og:url" content="https://chanchangxing.me/2019/04/30/RecyclerView源码解析/index.html">
<meta property="og:site_name" content="chanchangxing">
<meta property="og:description" content="RecyclerView渲染流程和获取缓存RecyclerView也是一个View，也要遵循View的三个步骤。onMeasure、onLayout、onDraw. 
那么就来照着这个顺序来解剖RecyclerView。 
解剖依照的项目是google的android sample 
onLayout在RecyclerView中，子View都是在LayoutManger中进行计算大小，布局的。所以">
<meta property="og:image" content="https://chanchangxing.me/2019/04/30/RecyclerView源码解析/1.png">
<meta property="og:updated_time" content="2019-05-10T14:50:42.608Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RecyclerView源码解析">
<meta name="twitter:description" content="RecyclerView渲染流程和获取缓存RecyclerView也是一个View，也要遵循View的三个步骤。onMeasure、onLayout、onDraw. 
那么就来照着这个顺序来解剖RecyclerView。 
解剖依照的项目是google的android sample 
onLayout在RecyclerView中，子View都是在LayoutManger中进行计算大小，布局的。所以">
<meta name="twitter:image" content="https://chanchangxing.me/2019/04/30/RecyclerView源码解析/1.png">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/typing.css">
  <link rel="stylesheet" href="/css/donate.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css">
  
</head>

  
    
      <body class="dark">
    
  
      <div id="container" class="container">
        <article id="post-RecyclerView源码解析" class="article article-type-post" itemscope itemprop="blogPost">
  <header id="header" class="header">
  <nav class="mobile-nav">
    <h1 class="nickname">铲昶行的智障空间</h1>
    <ul class="mobile-nav-menu">
      <label for="mobile-menu-toggle"><a>&#9776; Menu</a></label>
      <input type="checkbox" id="mobile-menu-toggle"/>
      <ul class="mobile-nav-link">
        
        <a href="/">首页</a>
        
        <a href="/archives">文章</a>
        
        <a href="/tags/android">Android</a>
        
        <a href="/tags/reactnative/">ReactNative</a>
        
        <a href="/tags/leetcode">Leetcode</a>
        
        <a href="/tags/面试总结">面试总结</a>
        
      </ul>
    </ul>
  </nav>
	
		<nav id="main-nav" class="main-nav nav-left">
	
	
	  <a class="main-nav-link" href="/">首页</a>
	
	  <a class="main-nav-link" href="/archives">文章</a>
	
	  <a class="main-nav-link" href="/tags/android">Android</a>
	
	  <a class="main-nav-link" href="/tags/reactnative/">ReactNative</a>
	
	  <a class="main-nav-link" href="/tags/leetcode">Leetcode</a>
	
	  <a class="main-nav-link" href="/tags/面试总结">面试总结</a>
	
  </nav>
</header>

  <hr/>
  <div class="article-inner">
    

    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      RecyclerView源码解析
    </h1>
  

      </header>
    
    <div class="article-entry typo" itemprop="articleBody">
      
        <h4 id="RecyclerView渲染流程和获取缓存"><a href="#RecyclerView渲染流程和获取缓存" class="headerlink" title="RecyclerView渲染流程和获取缓存"></a>RecyclerView渲染流程和获取缓存</h4><p>RecyclerView也是一个View，也要遵循View的三个步骤。<code>onMeasure</code>、<code>onLayout</code>、<code>onDraw</code>. </p>
<p>那么就来照着这个顺序来解剖RecyclerView。 </p>
<p>解剖依照的项目是google的<a href="https://github.com/googlesamples/android-RecyclerView/#readme" target="_blank" rel="external">android sample</a> </p>
<h5 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout"></a>onLayout</h5><p>在<code>RecyclerView</code>中，子View都是在<code>LayoutManger</code>中进行计算大小，布局的。所以其实<code>RecyclerView</code>的<code>onLayout()</code>方法只是一个空壳。这里就可以简化<code>RecyclerView</code>的<code>onLayout()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecyclerView</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dispatchLayout</span><span class="params">()</span> </span>&#123; </div><div class="line">        <span class="comment">//... </span></div><div class="line">        mState.mIsMeasuring = <span class="keyword">false</span>; </div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mState.mLayoutStep == State.STEP_START) &#123; </div><div class="line">            <span class="comment">// 在RecyclerView中，最重要的就是调用下面这个方法。</span></div><div class="line">            dispatchLayoutStep2(); </div><div class="line">        &#125;</div><div class="line">      	</div><div class="line">      	<span class="comment">// ...</span></div><div class="line">      	</div><div class="line">        <span class="comment">// step3中间有主要的流程，是关于缓存的，但是我们还没有走到缓存 </span></div><div class="line">        <span class="comment">// 所以我们就不看了 </span></div><div class="line">        dispatchLayoutStep3(); </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecyclerView</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchLayoutStep2</span><span class="params">()</span> </span>&#123; </div><div class="line">        <span class="comment">//... </span></div><div class="line"></div><div class="line">        <span class="comment">// 之后就进入最关键的onLayoutChildren。</span></div><div class="line">      	<span class="comment">// 也就是从这里开始，layout移交给LayoutManager处理。</span></div><div class="line">        mLayout.onLayoutChildren(mRecycler, mState); </div><div class="line"></div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearLayoutManager</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLayoutChildren</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state)</span> </span>&#123; </div><div class="line">    <span class="comment">// layout algorithm: </span></div><div class="line">    <span class="comment">// 1) by checking children and other variables, find an anchor coordinate and an anchor </span></div><div class="line">    <span class="comment">// item position. </span></div><div class="line">    <span class="comment">// 通过检查子项和其他变量，找到锚点坐标和锚点项目位置 </span></div><div class="line">    <span class="comment">// 2) fill towards start, stacking from bottom </span></div><div class="line">    <span class="comment">// 从下往上填充，从底部开始堆 </span></div><div class="line">    <span class="comment">// 3) fill towards end, stacking from top </span></div><div class="line">    <span class="comment">// 从上往下填充，从顶部开始堆 </span></div><div class="line">    <span class="comment">// 4) scroll to fulfill requirements like stack from bottom. </span></div><div class="line">    <span class="comment">// create layout state </span></div><div class="line">    <span class="comment">// 滚动以满足从底部堆栈的要求。创建布局状态 </span></div><div class="line"></div><div class="line">    <span class="comment">// 看到这里我们其实有</span></div><div class="line">    <span class="keyword">if</span> (mAnchorInfo.mLayoutFromEnd) &#123; </div><div class="line">        <span class="comment">//... </span></div><div class="line">    &#125; <span class="keyword">else</span> &#123; </div><div class="line">        <span class="comment">// 这里有两个fill()，这里要说明一下。</span></div><div class="line">      	<span class="comment">// 前面省略的代码有一个锚的概念.</span></div><div class="line">        <span class="comment">// 它通过一系列的计算得出自己要的锚在屏幕哪个位置.</span></div><div class="line">        <span class="comment">// 然后再在从锚点开始，从锚点到顶，从锚点到底进行layout和draw</span></div><div class="line">        <span class="comment">// 这里我们进入fill方法分析一下。</span></div><div class="line">        fill(recycler, mLayoutState, state, <span class="keyword">false</span>); </div><div class="line">	</div><div class="line">      	<span class="comment">// ...</span></div><div class="line">      	</div><div class="line">        fill(recycler, mLayoutState, state, <span class="keyword">false</span>); </div><div class="line">        <span class="comment">// ... </span></div><div class="line">    &#125; </div><div class="line">    <span class="comment">// ... </span></div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecyclerView</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fill</span><span class="params">(RecyclerView.Recycler recycler, LayoutState layoutState, RecyclerView.State state, <span class="keyword">boolean</span> stopOnFocusable)</span> </span>&#123; </div><div class="line">				</div><div class="line">      	<span class="comment">// ... </span></div><div class="line">        <span class="keyword">while</span> ((layoutState.mInfinite || remainingSpace &gt; <span class="number">0</span>) &amp;&amp; layoutState.hasMore(state)) &#123; </div><div class="line">          	<span class="comment">// 得到的结果就是拿到了adapter的view，</span></div><div class="line">            <span class="comment">// 并加入到了RecyclerView，并且已经做了measure和layout</span></div><div class="line">            <span class="comment">// 需要进入这个方法进行分析。</span></div><div class="line">            layoutChunk(recycler, state, layoutState, layoutChunkResult); </div><div class="line">            <span class="comment">// ...</span></div><div class="line">        &#125; </div><div class="line">        <span class="comment">// ... </span></div><div class="line"></div><div class="line">        <span class="keyword">return</span> start - layoutState.mAvailable; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearLayoutManager</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">layoutChunk</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state, LayoutState layoutState, LayoutChunkResult result)</span> </span>&#123; </div><div class="line">        <span class="comment">// 这个next()方法就是获取RecyclerView的缓存的ViewHolder的中				 // 的View的方法.</span></div><div class="line">        <span class="comment">// 缓存机制分为三层，</span></div><div class="line">      	<span class="comment">// 第一层通过CacheView把控，存在这里的ViewHolder不会调用onCreateViewHolder和onBindViewHolder方法。</span></div><div class="line">      	<span class="comment">// 第二层通过ViewCacheExtension实现，这层缓存通过用户自定义实现，但是这里有个很奇怪的事情是我并不知道该如何给RecyclerView，因为RecyclerView缓存ViewHolder的时候并没有一个接口导出来。</span></div><div class="line">      	<span class="comment">// 第三层通过RecyclerPool实现，RecyclerPool用viewType来存储ViewHolder。</span></div><div class="line">      	<span class="comment">// 这里就是获取缓存的重中之重了。那么来分析这个方法</span></div><div class="line">        View view = layoutState.next(recycler); </div><div class="line">       </div><div class="line">        <span class="comment">// ... </span></div><div class="line"></div><div class="line">        LayoutParams params = (LayoutParams) view.getLayoutParams(); </div><div class="line">        <span class="keyword">if</span> (layoutState.mScrapList == <span class="keyword">null</span>) &#123; </div><div class="line">            <span class="keyword">if</span> (mShouldReverseLayout == (layoutState.mLayoutDirection </div><div class="line">            == LayoutState.LAYOUT_START)) &#123; </div><div class="line">                <span class="comment">// 这里addView做了两个操作 </span></div><div class="line">                <span class="comment">// 将这个view放入ChildHelper的bucket中 </span></div><div class="line">                <span class="comment">// 将view加入到RecyclerView中 </span></div><div class="line">                addView(view); </div><div class="line">            &#125; <span class="keyword">else</span> &#123; </div><div class="line">                </div><div class="line">            &#125; </div><div class="line">        &#125; <span class="keyword">else</span> &#123; </div><div class="line">            <span class="comment">// ... </span></div><div class="line">        &#125; </div><div class="line">        <span class="comment">// 后面有一系列的操作，各种计算，都是为了measuer和layout我们得 </span></div><div class="line">        <span class="comment">// 到的ViewHolder的view。 </span></div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearLayoutManager</span>.<span class="title">LayoutState</span> </span>&#123; </div><div class="line">    <span class="function">View <span class="title">next</span><span class="params">(RecyclerView.Recycler recycler)</span> </span>&#123; </div><div class="line">        <span class="comment">//... </span></div><div class="line"></div><div class="line">        <span class="comment">// 进入getViewForPosition()方法</span></div><div class="line">        <span class="keyword">final</span> View view = recycler.getViewForPosition(mCurrentPosition); </div><div class="line">        mCurrentPosition += mItemDirection; </div><div class="line">        </div><div class="line">        <span class="keyword">return</span> view; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Recycler</span> </span>&#123; </div><div class="line">  	</div><div class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">getViewForPosition</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123; </div><div class="line">        <span class="comment">// 直接进入getViewForPosition()方法。 </span></div><div class="line">        <span class="keyword">return</span> getViewForPosition(position, <span class="keyword">false</span>); </div><div class="line">    &#125; </div><div class="line">  </div><div class="line">  	<span class="comment">// 这个方法就是我们真正获取或者创建ViewHolder的地方了。</span></div><div class="line">  	<span class="comment">// 这里的逻辑和之前描述缓存的意思相同，</span></div><div class="line">  	<span class="comment">// 先通过CacheView、再通过ViewCacheExtension、最后通过RecyclerPool方法。如果三个缓存里都没有的话，那只能重新创建了。</span></div><div class="line">		<span class="function">View <span class="title">getViewForPosition</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">boolean</span> dryRun)</span> </span>&#123; </div><div class="line">        <span class="comment">//...</span></div><div class="line">      </div><div class="line">        ViewHolder holder = <span class="keyword">null</span>; </div><div class="line">        </div><div class="line">        <span class="comment">//... </span></div><div class="line">        <span class="comment">// 1) Find from scrap by position </span></div><div class="line">        <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123; </div><div class="line">            <span class="comment">// 这里我简单对逻辑进行解释。</span></div><div class="line">          	<span class="comment">// 这里通过position来查找缓存</span></div><div class="line">          	<span class="comment">// 1.在mAttachedScrap列表查找ViewHolder。</span></div><div class="line">          	<span class="comment">// 2.在mHiddenViews列表中查找View。但是我还没有找到这个缓存是什么个情况。</span></div><div class="line">          	<span class="comment">// 3.在mCachedViews列表中查找ViewHolder。这里可以真正的称之为第一层缓存。</span></div><div class="line">            holder = getScrapViewForPosition(position, INVALID_TYPE, dryRun); </div><div class="line">        &#125; </div><div class="line"></div><div class="line">        <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123; </div><div class="line">        		<span class="comment">// ...	</span></div><div class="line">          </div><div class="line">        		<span class="comment">// 2) Find from scrap via stable ids, if exists </span></div><div class="line">        		<span class="keyword">if</span> (mAdapter.hasStableIds()) &#123; </div><div class="line">              	<span class="comment">// 这里通过adapter的itemId来在mAttachedScrap中查抄ViewHolder。</span></div><div class="line">        				holder = getScrapViewForId(mAdapter.getItemId(offsetPosition), type, dryRun);</div><div class="line"></div><div class="line">        		&#125; </div><div class="line"></div><div class="line">          	<span class="comment">// 这里就是用户自定义的缓存方法了，他只是调用了外面的接口，而接口返回的view就是要我们来提供了。说不定以后我们会学习一下怎么来设置自定义缓存</span></div><div class="line">            <span class="keyword">if</span> (holder == <span class="keyword">null</span> &amp;&amp; mViewCacheExtension != <span class="keyword">null</span>) &#123; </div><div class="line">            		<span class="comment">// ...</span></div><div class="line">            &#125; </div><div class="line"></div><div class="line">        		<span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</div><div class="line">        				<span class="comment">// 这里通过viewType去RecyclerViewPool来找相同的viewType的ViewHolder </span></div><div class="line">        				holder = getRecycledViewPool().getRecycledView(type); </div><div class="line">        		&#125; </div><div class="line"></div><div class="line">            <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123; </div><div class="line">                <span class="comment">// 走到这里说明已经没有缓存了，直接重新构建 // ViewHolder的生命周期了 </span></div><div class="line">                holder = mAdapter.createViewHolder(RecyclerView.<span class="keyword">this</span>, type); </div><div class="line">                <span class="comment">//... </span></div><div class="line">            &#125; </div><div class="line">        &#125; </div><div class="line"></div><div class="line">        <span class="comment">//... </span></div><div class="line">        <span class="keyword">boolean</span> bound = <span class="keyword">false</span>; </div><div class="line">        <span class="keyword">if</span> (mState.isPreLayout() &amp;&amp; holder.isBound()) &#123; </div><div class="line">        		<span class="comment">// ... </span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) &#123; </div><div class="line">        		<span class="comment">// ... </span></div><div class="line">            <span class="comment">// 这里最重要的就是走了adapter的bindViewHolder方法,</span></div><div class="line">          	<span class="comment">// 在CacheView不会进入这个逻辑，且不会调用bindViewHolder方法，而其他缓存出来的ViewHolder会进入这个方法。</span></div><div class="line">            mAdapter.bindViewHolder(holder, offsetPosition); </div><div class="line">            <span class="comment">// ... </span></div><div class="line">        &#125; </div><div class="line"></div><div class="line">        <span class="comment">// 这里的操作已经无伤大雅了。略过 </span></div><div class="line">        <span class="keyword">return</span> holder.itemView; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="onDraw"><a href="#onDraw" class="headerlink" title="onDraw"></a>onDraw</h5><p><code>RecyclerView</code>的<code>onDraw()</code>方法主要是用来渲染<code>ItemDecoration()</code>，而<code>onDraw()</code>方法里会调用<code>onDrawChild()</code>，对每个ViewHolder进行渲染，所以没啥好解释的。 </p>
<p><b>小结一下</b>：到这里我们总结了关于RecyclerView的初始化流程和获取缓存ViewHolder的流程。</p>
<p>RecyclerView自己做的事情其实是比较少的，对于Layout流程他差不多都是给到LayoutManager来执行，LayoutManger执行每个Item的onLayout方法。</p>
<p>RecyclerView的缓存是交给Recycler来管理，获取缓存的流程是通过CacheView、ViewCacheExtension、RecyclerPool来执行的。</p>
<p>CacheView的ViewHolder完全保持Item之前的状态，既不会走onCreateViewHolder也不会走onBindViewHolder。CacheView的默认最大容量是两个，可以自定义修改。</p>
<p>ViewCacheExtension暂时不知道怎么使用，网上也没有啥例子可以参考。</p>
<p>RecyclerPool是通过ViewType来进行管理的，多个RecyclerView可以共用一个RecyclerPool，当CacheView放不下的时候，栈底的元素就会放到RecyclerPool中。</p>
<h4 id="RecyclerView滑动和放入缓存"><a href="#RecyclerView滑动和放入缓存" class="headerlink" title="RecyclerView滑动和放入缓存"></a>RecyclerView滑动和放入缓存</h4><p>上面的初始化和显示分析了获取缓存的流程和逻辑，而只是获取缓存，没有加入缓存的话那么这个分析也是没有意义的。</p>
<p>RecyclerView的的滑动就是加入缓存的一个入口，当页面上有Item被划出屏幕的时候，那么这个Item的ViewHolder就加入到缓存了。</p>
<p>触发滑动事件大部分是用户用手机滑动屏幕进行，所以滑动的入口就是在监听滑动事件的onTouchEvent的ACTION_MOVE事件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecyclerView</span> </span>&#123;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent e)</span> </span>&#123;</div><div class="line">				<span class="keyword">switch</span> (action) &#123;</div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</div><div class="line">              	<span class="comment">// 这个是scroll事件的内部实现</span></div><div class="line">              	<span class="keyword">if</span> (scrollByInternal(</div><div class="line">                            canScrollHorizontally ? dx : <span class="number">0</span>,</div><div class="line">                            canScrollVertically ? dy : <span class="number">0</span>,</div><div class="line">                            vtev)) &#123;</div><div class="line">                &#125;</div><div class="line">              	<span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecyclerView</span> </span>&#123;</div><div class="line">		<span class="function"><span class="keyword">boolean</span> <span class="title">scrollByInternal</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, MotionEvent ev)</span> </span>&#123;</div><div class="line">      	<span class="keyword">if</span> (mAdapter != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (y != <span class="number">0</span>) &#123;</div><div class="line">              	<span class="comment">// 因为我们的设定是竖直方向进行滑动，所以是进入这个逻辑</span></div><div class="line">                consumedY = mLayout.scrollVerticallyBy(y, mRecycler, mState);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​        scrollVerticallyBy这个方法也是走的LayoutManager，所以说，LayoutManager还承接了滑动的真实逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearLayoutManager</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">scrollVerticallyBy</span><span class="params">(<span class="keyword">int</span> dy, RecyclerView.Recycler recycler,</span></span></div><div class="line">            RecyclerView.State state) &#123;</div><div class="line">        <span class="keyword">return</span> scrollBy(dy, recycler, state);</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">  	<span class="function"><span class="keyword">int</span> <span class="title">scrollBy</span><span class="params">(<span class="keyword">int</span> dy, RecyclerView.Recycler recycler, RecyclerView.State state)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> consumed = mLayoutState.mScrollingOffset</div><div class="line">                + fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们又走到了fill方法，而fill方法就是保证新滑动出来的item能够被填充到RecyclerView中。因为我们之前已经在fill方法中分析过获取缓存的方法，这里分析fill方法我们把重点放到将Item放入缓存的流程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearLayoutManager</span> </span>&#123;</div><div class="line">		<span class="function"><span class="keyword">int</span> <span class="title">fill</span><span class="params">(RecyclerView.Recycler recycler, LayoutState layoutState, RecyclerView.State state, <span class="keyword">boolean</span> stopOnFocusable)</span> </span>&#123;</div><div class="line">				<span class="keyword">if</span> (layoutState.mScrollingOffset != LayoutState.SCOLLING_OFFSET_NaN) &#123;</div><div class="line">          	<span class="comment">// 这里就是回收Item的入口</span></div><div class="line">            recycleByLayoutState(recycler, layoutState);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearLayoutManager</span> </span>&#123;</div><div class="line">		<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recycleByLayoutState</span><span class="params">(RecyclerView.Recycler recycler, LayoutState layoutState)</span> </span>&#123;</div><div class="line">      			<span class="comment">// 这个方法是从上开始回收Item。</span></div><div class="line">            recycleViewsFromStart(recycler, layoutState.mScrollingOffset);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearLayoutManager</span> </span>&#123;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</div><div class="line">            View child = getChildAt(i);</div><div class="line">            <span class="keyword">if</span> (mOrientationHelper.getDecoratedEnd(child) &gt; limit || mOrientationHelper.getTransformedEndWithDecoration(child) &gt; limit) &#123;</div><div class="line">              recycleChildren(recycler, <span class="number">0</span>, i);</div><div class="line">              <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关于找出要回收的Item的逻辑比较有意思。</p>
<img src="/2019/04/30/RecyclerView源码解析/1.png" alt="1.png" title="">
<p>所以他是通过滑动距离和每个item的底部的坐标来判断item的上一个item是否划出了屏幕。</p>
<p>下面来看看是怎么回收Item。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearLayoutManager</span> </span>&#123;</div><div class="line">		<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recycleChildren</span><span class="params">(RecyclerView.Recycler recycler, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (startIndex == endIndex) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (endIndex &gt; startIndex) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = endIndex - <span class="number">1</span>; i &gt;= startIndex; i--) &#123;</div><div class="line">                removeAndRecycleViewAt(i, recycler);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeAndRecycleViewAt</span><span class="params">(<span class="keyword">int</span> index, Recycler recycler)</span> </span>&#123;</div><div class="line">      	<span class="comment">// 获取这个ViewHolder的view。</span></div><div class="line">        <span class="keyword">final</span> View view = getChildAt(index);</div><div class="line">      	<span class="comment">// 在页面上删除这个已经移出的view。</span></div><div class="line">        removeViewAt(index);</div><div class="line">      	<span class="comment">// 将view交给Recycler，Recycler来完成回收的动作</span></div><div class="line">        recycler.recycleView(view);</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycleView</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">        recycleViewHolderInternal(holder);</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">  	<span class="function"><span class="keyword">void</span> <span class="title">recycleViewHolderInternal</span><span class="params">(ViewHolder holder)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (forceRecycle || holder.isRecyclable()) &#123;</div><div class="line">            <span class="keyword">if</span> (!holder.hasAnyOfTheFlags(ViewHolder.FLAG_INVALID | ViewHolder.FLAG_REMOVED | ViewHolder.FLAG_UPDATE)) &#123;</div><div class="line">                <span class="keyword">int</span> cachedViewSize = mCachedViews.size();</div><div class="line">              	<span class="comment">// 当cachedView的数量大于等于最大缓存数的时候，那么把最开始加入到CacheView的Item移出，把新的Item放进CacheView。然后把移出的Item放入到RecyclerPool中。</span></div><div class="line">                <span class="keyword">if</span> (cachedViewSize &gt;= mViewCacheMax &amp;&amp; cachedViewSize &gt; <span class="number">0</span>) &#123;</div><div class="line">                    recycleCachedViewAt(<span class="number">0</span>);</div><div class="line">                    cachedViewSize --;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (cachedViewSize &lt; mViewCacheMax) &#123;</div><div class="line">                  mCachedViews.add(holder);</div><div class="line">                  cached = <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">          	<span class="comment">// 这里我们再看看RecyclerPool是如何存储被回收的Item的。</span></div><div class="line">            <span class="keyword">if</span> (!cached) &#123;</div><div class="line">                addViewHolderToRecycledViewPool(holder);</div><div class="line">                recycled = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125; </div><div class="line">    &#125;</div><div class="line">  </div><div class="line">  	<span class="function"><span class="keyword">void</span> <span class="title">addViewHolderToRecycledViewPool</span><span class="params">(ViewHolder holder)</span> </span>&#123;</div><div class="line">        getRecycledViewPool().putRecycledView(holder);</div><div class="line">  	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecycledViewPool</span> </span>&#123;</div><div class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putRecycledView</span><span class="params">(ViewHolder scrap)</span> </span>&#123;</div><div class="line">      	<span class="comment">// 首先拿到这个ViewHolder的viewType。</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> viewType = scrap.getItemViewType();</div><div class="line">      	<span class="comment">// 通过这个viewType拿到相对应的存储的列表，简单介绍里面的逻辑，从一个map中拿到这个list，如果没有个这个kv值，那么重新创建一个list并放入到这个map，并且创建一个这个viewType的最大值放入到另一个map中。最大值默认为5.</span></div><div class="line">        <span class="keyword">final</span> ArrayList scrapHeap = getScrapHeapForType(viewType);</div><div class="line">      	<span class="comment">// 如果RecyclerPool中这个viewType的数量已经达到最大值，那么直接不存储了。</span></div><div class="line">        <span class="keyword">if</span> (mMaxScrap.get(viewType) &lt;= scrapHeap.size()) &#123;</div><div class="line">          	<span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">      	<span class="comment">// 如果RecyclerPool中这个viewType的数量小于最大值，那么存入RecyclerPool中。</span></div><div class="line">        scrap.resetInternal();</div><div class="line">        scrapHeap.add(scrap);</div><div class="line">  	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此，关于RecyclerView的缓存流程已经完成，这里我们总结一下，</p>
<p>1.RecyclerView分为三级缓存，cacheView，自定义缓存和RecyclerPool。</p>
<p>2.CacheView默认最大为两个，会保存Item的状态。(不会去调用onBindViewHolder)</p>
<p>3.RecyclerPool根据viewType来管理存储，不会保存Item的状态(会去调用onBindViewHolder)</p>
<p>4.自定义缓存只有让客户端程序员自己定义，并没有在回收Item的时候对其进行操作。</p>

      
      
    </div>
    <footer class="article-footer">
      <ul class="article-meta">
        <li>
          <span class="label">Published Date:</span>
          <a href="/2019/04/30/RecyclerView源码解析/" class="article-date">
  <time datetime="2019-04-30T06:46:22.000Z" itemprop="datePublished">2019-04-30</time>
</a>

        </li>
        
        
          <li>
            <span class="label">Tag:</span>
            
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li></ul>


          </li>
        
        <hr/>
      </ul>
    </footer>
  </div>
  
    
<nav id="article-nav" class="article-nav">
  
    <a href="/2019/12/02/ARouter解析/" id="article-nav-newer" class="article-nav-link-wrap newer">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          ARouter
        
      </div>
    </a>
  
  
    <a href="/2019/04/10/单词搜索/" id="article-nav-older" class="article-nav-link-wrap older">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">单词搜索</div>
    </a>
  
</nav>


  
</article>










      </div>
      
    <footer id="footer" class="post-footer footer">
      
        <ul class="footer-links">
          
            <li><a href="/archives/"><span class="fa fa-book"></span></a></li>
          
            <li><a href="https://github.com/chanchangxing"><span class="fa fa-globe"></span></a></li>
          
        </ul>
	    
      <hr/>
      <div id="footerContent" class="footer-content">
        <p>这篇写完就删站</p>


      </div>
    </footer>

      







<script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>


  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>


<script src="/js/typing.js"></script>
<!--[if lt IE 9]><script src="https://cdn.jsdelivr.net/npm/html5shiv@3/dist/html5shiv.min.js"></script><![endif]-->







    </div>
  </body>
</html>
