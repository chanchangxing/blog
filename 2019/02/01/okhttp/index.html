<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  
  <title>okhttp | chanchangxing</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="okhttp源码分析okhttp有两种创建实例的方式，一种是直接new，另一种是通过他的builder，我们就直接通过builder来进行创建，先用最简单的builder来创建。
12345OkHttpClient.Builder client = new OkHttpClient.Builder();Request request = new Request.Builder()    .url(">
<meta property="og:type" content="article">
<meta property="og:title" content="okhttp">
<meta property="og:url" content="https://chanchangxing.me/2019/02/01/okhttp/index.html">
<meta property="og:site_name" content="chanchangxing">
<meta property="og:description" content="okhttp源码分析okhttp有两种创建实例的方式，一种是直接new，另一种是通过他的builder，我们就直接通过builder来进行创建，先用最简单的builder来创建。
12345OkHttpClient.Builder client = new OkHttpClient.Builder();Request request = new Request.Builder()    .url(">
<meta property="og:updated_time" content="2019-02-11T08:30:21.257Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="okhttp">
<meta name="twitter:description" content="okhttp源码分析okhttp有两种创建实例的方式，一种是直接new，另一种是通过他的builder，我们就直接通过builder来进行创建，先用最简单的builder来创建。
12345OkHttpClient.Builder client = new OkHttpClient.Builder();Request request = new Request.Builder()    .url(">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/typing.css">
  <link rel="stylesheet" href="/css/donate.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css">
  
</head>

  
    
      <body class="dark">
    
  
      <div id="container" class="container">
        <article id="post-okhttp" class="article article-type-post" itemscope itemprop="blogPost">
  <header id="header" class="header">
  <nav class="mobile-nav">
    <h1 class="nickname">铲昶行的智障空间</h1>
    <ul class="mobile-nav-menu">
      <label for="mobile-menu-toggle"><a>&#9776; Menu</a></label>
      <input type="checkbox" id="mobile-menu-toggle"/>
      <ul class="mobile-nav-link">
        
        <a href="/">首页</a>
        
        <a href="/archives">文章</a>
        
        <a href="/tags/android">Android</a>
        
        <a href="/tags/reactnative/">ReactNative</a>
        
        <a href="/tags/leetcode">Leetcode</a>
        
      </ul>
    </ul>
  </nav>
	
		<nav id="main-nav" class="main-nav nav-left">
	
	
	  <a class="main-nav-link" href="/">首页</a>
	
	  <a class="main-nav-link" href="/archives">文章</a>
	
	  <a class="main-nav-link" href="/tags/android">Android</a>
	
	  <a class="main-nav-link" href="/tags/reactnative/">ReactNative</a>
	
	  <a class="main-nav-link" href="/tags/leetcode">Leetcode</a>
	
  </nav>
</header>

  <hr/>
  <div class="article-inner">
    

    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      okhttp
    </h1>
  

      </header>
    
    <div class="article-entry typo" itemprop="articleBody">
      
        <h4 id="okhttp源码分析"><a href="#okhttp源码分析" class="headerlink" title="okhttp源码分析"></a>okhttp源码分析</h4><p><code>okhttp</code>有两种创建实例的方式，一种是直接new，另一种是通过他的<code>builder</code>，我们就直接通过builder来进行创建，先用最简单的builder来创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">OkHttpClient.Builder client = <span class="keyword">new</span> OkHttpClient.Builder();</div><div class="line">Request request = <span class="keyword">new</span> Request.Builder()</div><div class="line">    .url(<span class="string">"https://api.github.com/"</span>)</div><div class="line">    .build();</div><div class="line">client.build().newCall(request).execute();</div></pre></td></tr></table></figure>
<p>builder里面初始化了okhttp需要的类，我们可以先不去管他，到用的时候再去这里找。</p>
<p>之后我们来看Request的builder</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</div><div class="line">    <span class="comment">// buider的构造函数就做了两个事情</span></div><div class="line">    <span class="comment">// 一个是将method默认为‘get’</span></div><div class="line">    <span class="comment">// 创建一个Headers.Builder</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.method = <span class="string">"GET"</span>;</div><div class="line">        <span class="keyword">this</span>.headers = <span class="keyword">new</span> Headers.Builder();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Header.Builder没有构造函数，</span></div><div class="line"><span class="comment">// 但是他会在类加载的时候创建一个List</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Headers</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">        <span class="comment">// 这个方法直接要了20个长度的内存</span></div><div class="line">        <span class="keyword">final</span> List&lt;String&gt; namesAndValues = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">20</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>url我们就不看了，直接看<code>build()</code>吧。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> Request <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (url == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"url == null"</span>);</div><div class="line">            <span class="comment">// Request的构造函数就是把Request创建好的实例放到Request中。</span></div><div class="line">            <span class="comment">// 在构造函数中把Header.Buider给build好</span></div><div class="line">            <span class="comment">// Header的构造函数也就是把Builder创建的实例放到Header中</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Request(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看完Request，就可以看OkhttpClient，OkhttpClient.Builder还是和之前的builder一样，所以我们直接看<code>newCall(request)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">  * Prepares the &#123;<span class="doctag">@code</span> request&#125; to be executed at some point in the future.</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OkHttpClient</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Call</span>.<span class="title">Factory</span>, <span class="title">WebSocket</span>.<span class="title">Factory</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call <span class="title">newCall</span><span class="params">(Request request)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> RealCall.newRealCall(<span class="keyword">this</span>, request, <span class="keyword">false</span> <span class="comment">/* for web socket */</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RealCall</span> <span class="keyword">implements</span> <span class="title">Call</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">static</span> RealCall <span class="title">newRealCall</span><span class="params">(OkHttpClient client, Request originalRequest, <span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</div><div class="line">        <span class="comment">// Safely publish the Call instance to the EventListener.</span></div><div class="line">        RealCall call = <span class="keyword">new</span> RealCall(client, originalRequest, forWebSocket);</div><div class="line">        call.eventListener = client.eventListenerFactory().create(call);</div><div class="line">        <span class="keyword">return</span> call;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">RealCall</span><span class="params">(OkHttpClient client, Request originalRequest, <span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.client = client;</div><div class="line">        <span class="keyword">this</span>.originalRequest = originalRequest;</div><div class="line">        <span class="keyword">this</span>.forWebSocket = forWebSocket;</div><div class="line">        <span class="comment">// 这个Interceptor之后会用到。</span></div><div class="line">        <span class="keyword">this</span>.retryAndFollowUpInterceptor = <span class="keyword">new</span> RetryAndFollowUpInterceptor(client, forWebSocket);</div><div class="line">        <span class="comment">// timeout是okio部分，所以我们这里先不分析</span></div><div class="line">        <span class="keyword">this</span>.timeout = <span class="keyword">new</span> AsyncTimeout() &#123;</div><div class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">timedOut</span><span class="params">()</span> </span>&#123;</div><div class="line">                cancel();</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        <span class="keyword">this</span>.timeout.timeout(client.callTimeoutMillis(), MILLISECONDS);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之后我们要分析<code>execute()</code>，okhttp有两个执行的方法，<code>execute()</code>和<code>enqueue()</code>，前一个是同步的，后一个是异步的。我们先来分析<code>execute()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RealCall</span> <span class="keyword">implements</span> <span class="title">Call</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        ...</div><div class="line">        <span class="comment">// eventListener是用来给到用户监听的。</span></div><div class="line">        eventListener.callStart(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 这个方法是将这次请求纪录下来，说明他已经在running了</span></div><div class="line">            client.dispatcher().executed(<span class="keyword">this</span>);</div><div class="line">            <span class="comment">// 接下来分析这个方法</span></div><div class="line">            Response result = getResponseWithInterceptorChain();</div><div class="line">            <span class="keyword">if</span> (result == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e = timeoutExit(e);</div><div class="line">            eventListener.callFailed(<span class="keyword">this</span>, e);</div><div class="line">            <span class="keyword">throw</span> e;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            client.dispatcher().finished(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来分析<code>getResponseWithInterceptorChain()</code>，这个方法是开始进入主流程的入口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="comment">// Build a full stack of interceptors.</span></div><div class="line">    List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    interceptors.addAll(client.interceptors());</div><div class="line">    interceptors.add(retryAndFollowUpInterceptor);</div><div class="line">    interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));</div><div class="line">    interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</div><div class="line">    interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));</div><div class="line">    <span class="comment">// forWebSocket在调用newRealCall方法时传入的false</span></div><div class="line">    <span class="comment">// 所以networkInterceptors会加入到interceptors</span></div><div class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</div><div class="line">        interceptors.addAll(client.networkInterceptors());</div><div class="line">    &#125;</div><div class="line">    interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));</div><div class="line">    <span class="comment">// 这里总结一下，搞清楚interceptors这个列表里面有什么东西</span></div><div class="line">    <span class="comment">// [retryAndFollowUpInterceptor, BridgeInterceptor,</span></div><div class="line">    <span class="comment">//  CacheInterceptor, ConnectInterceptor, </span></div><div class="line">    <span class="comment">//  networkInterceptors， CallServerInterceptor]</span></div><div class="line">    <span class="comment">// 之后每个Request都会进入到这几个Interceptor，然后返回出Response。</span></div><div class="line"></div><div class="line">    <span class="comment">// 这里只是做一些常规的初始化。</span></div><div class="line">    Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(</div><div class="line">        interceptors, <span class="keyword">null</span>, <span class="keyword">null</span>, </div><div class="line">        <span class="keyword">null</span>, <span class="number">0</span>, originalRequest, </div><div class="line">        <span class="keyword">this</span>, eventListener, client.connectTimeoutMillis(),</div><div class="line">		client.readTimeoutMillis(), client.writeTimeoutMillis());</div><div class="line"></div><div class="line">    <span class="comment">// 接下来我们就来分析这个方法</span></div><div class="line">    <span class="keyword">return</span> chain.proceed(originalRequest);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来我们来分析<code>RealInterceptorChain.proceed()</code>，proceed里面还有一个重载的方法，我们直接看看传入了什么值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">return</span> proceed(request, </div><div class="line">                   streamAllocation <span class="comment">/* null */</span>, </div><div class="line">                   httpCodec <span class="comment">/* null */</span>, </div><div class="line">                   connection <span class="comment">/* null */</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了request，其他参数都是null，那么我们就可以真正分析proceed方法了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    ...</div><div class="line"></div><div class="line">	<span class="comment">// 这里又创建了一次RealInterceptorChain，只是把index+1。</span></div><div class="line">    RealInterceptorChain next = <span class="keyword">new</span> RealInterceptorChain(</div><div class="line">        interceptors, streamAllocation, httpCodec, </div><div class="line">        connection, index + <span class="number">1</span>, request, </div><div class="line">        call, eventListener, connectTimeout, </div><div class="line">        readTimeout, writeTimeout);</div><div class="line">    <span class="comment">// 最初情况下，index = 0，</span></div><div class="line">    <span class="comment">// 所以我们get的就是RetryAndFollowUpInterceptor</span></div><div class="line">    Interceptor interceptor = interceptors.get(index);</div><div class="line">    <span class="comment">// 这里我们调用的是RetryAndFollowUpInterceptor.intercept()</span></div><div class="line">    Response response = interceptor.intercept(next);</div><div class="line">	...</div><div class="line">    <span class="keyword">return</span> response;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们看一下RetryAndFollowUpInterceptor的类的注释，再来分析<code>RetryAndFollowUpInterceptor.intercept()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * This interceptor recovers from failures and follows redirects as necessary. It may throw an</div><div class="line"> * &#123;<span class="doctag">@link</span> IOException&#125; if the call was canceled.</div><div class="line"> *  这个interceptor会恢复失败并且在必要的时候遵循重定向，这里可能会抛出一个异常如果请求被取消</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryAndFollowUpInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 这个Interceptor的intercept实例了很多东西，所以当我们用到的时候我们再去看这个方法。</div><div class="line">    **/</div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        Request request = chain.request();</div><div class="line">        RealInterceptorChain realChain = (RealInterceptorChain) chain;</div><div class="line">        Call call = realChain.call();</div><div class="line">        EventListener eventListener = realChain.eventListener();</div><div class="line"></div><div class="line">        StreamAllocation streamAllocation = <span class="keyword">new</span> StreamAllocation(</div><div class="line">            client.connectionPool(), createAddress(request.url()), </div><div class="line">            call, eventListener, callStackTrace);</div><div class="line">        <span class="keyword">this</span>.streamAllocation = streamAllocation;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> followUpCount = <span class="number">0</span>;</div><div class="line">        Response priorResponse = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="comment">// 到我们分析的情况，canceled为false。</span></div><div class="line">            <span class="keyword">if</span> (canceled) &#123;</div><div class="line">                streamAllocation.release();</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            Response response;</div><div class="line">            <span class="keyword">boolean</span> releaseConnection = <span class="keyword">true</span>;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// 这里是在调用创建RetryAndFollowUpInterceptor之前创建的Chain</span></div><div class="line">                <span class="comment">// 这样分析又回到了RealInterceptorChain,其中index = 1.</span></div><div class="line">                <span class="comment">// 我们通过上面的分析，直接可以得出他调用interceptors.get(1).intercept</span></div><div class="line">                response = realChain.proceed(request, streamAllocation, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">                releaseConnection = <span class="keyword">false</span>;</div><div class="line">            &#125; <span class="keyword">catch</span> (RouteException e) &#123;</div><div class="line">                ...</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                ...</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                ...</div><div class="line">            &#125;</div><div class="line">			...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以我们总结一下RetryAndFollowUpInterceptor在proceedz之前做了什么，其实就是创建了StreamAllocation，并执行了一个无线循环，里面执行到我们目前要分析的<code>realChain.proceed()</code>，也就是执行了BridgeInterceptor，所以我们要分析<code>BridgeInterceptor.intercept()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Bridges from application code to network code. First it builds a network request from a user</div><div class="line"> * request. Then it proceeds to call the network. Finally it builds a user response from the network</div><div class="line"> * response.</div><div class="line"> * 从应用程序代码到网络代码的桥梁。 </div><div class="line"> * 首先，它根据用户请求构建网络请求。 </div><div class="line"> * 然后它继续呼叫网络。 </div><div class="line"> * 最后，它根据网络响应构建用户响应。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BridgeInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        Request userRequest = chain.request();</div><div class="line">        Request.Builder requestBuilder = userRequest.newBuilder();</div><div class="line"></div><div class="line">        RequestBody body = userRequest.body();</div><div class="line">        <span class="comment">// 我们的请求没有body，所以我们暂时不用去分析这里。</span></div><div class="line">        <span class="keyword">if</span> (body != <span class="keyword">null</span>) &#123;</div><div class="line">            MediaType contentType = body.contentType();</div><div class="line">            <span class="keyword">if</span> (contentType != <span class="keyword">null</span>) &#123;</div><div class="line">                requestBuilder.header(<span class="string">"Content-Type"</span>, contentType.toString());</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">long</span> contentLength = body.contentLength();</div><div class="line">            <span class="keyword">if</span> (contentLength != -<span class="number">1</span>) &#123;</div><div class="line">                requestBuilder.header(<span class="string">"Content-Length"</span>, Long.toString(contentLength));</div><div class="line">                requestBuilder.removeHeader(<span class="string">"Transfer-Encoding"</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                requestBuilder.header(<span class="string">"Transfer-Encoding"</span>, <span class="string">"chunked"</span>);</div><div class="line">                requestBuilder.removeHeader(<span class="string">"Content-Length"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 当用户没有设置header的时候，会默认设置下面两个逻辑</span></div><div class="line">        <span class="keyword">if</span> (userRequest.header(<span class="string">"Host"</span>) == <span class="keyword">null</span>) &#123;</div><div class="line">            requestBuilder.header(<span class="string">"Host"</span>, hostHeader(userRequest.url(), <span class="keyword">false</span>));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (userRequest.header(<span class="string">"Connection"</span>) == <span class="keyword">null</span>) &#123;</div><div class="line">            requestBuilder.header(<span class="string">"Connection"</span>, <span class="string">"Keep-Alive"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// If we add an "Accept-Encoding: gzip" header field we're responsible for also decompressing</span></div><div class="line">        <span class="comment">// the transfer stream.</span></div><div class="line">        <span class="keyword">boolean</span> transparentGzip = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">if</span> (userRequest.header(<span class="string">"Accept-Encoding"</span>) == <span class="keyword">null</span> &amp;&amp; userRequest.header(<span class="string">"Range"</span>) == <span class="keyword">null</span>) &#123;</div><div class="line">            transparentGzip = <span class="keyword">true</span>;</div><div class="line">            requestBuilder.header(<span class="string">"Accept-Encoding"</span>, <span class="string">"gzip"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 查找这个Request之前是否有cookie，有的话把他加进header里。</span></div><div class="line">        List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());</div><div class="line">        <span class="keyword">if</span> (!cookies.isEmpty()) &#123;</div><div class="line">            requestBuilder.header(<span class="string">"Cookie"</span>, cookieHeader(cookies));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (userRequest.header(<span class="string">"User-Agent"</span>) == <span class="keyword">null</span>) &#123;</div><div class="line">            requestBuilder.header(<span class="string">"User-Agent"</span>, Version.userAgent());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 之后开始走CacheInterceptor.intercept</span></div><div class="line">        Response networkResponse = chain.proceed(requestBuilder.build());</div><div class="line">		...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>BridgeInterceptor的主要工作是将Request的header设置好，接下来我们来看<code>CacheInterceptor.intercept()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">  * Serves requests from the cache and writes responses to the cache. </div><div class="line">  * 提供来自缓存的请求并将响应写入缓存。</div><div class="line">**/</div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="comment">// 这个cache是用户在使用OkhttpClient.Builder自己创建的</span></div><div class="line">        <span class="comment">// 因为要分析整个流程，所以我们就当创建了这个cache。</span></div><div class="line">        <span class="comment">// 但是我们这算是第一次请求这个url，所以按道理来讲没有缓存。</span></div><div class="line">        <span class="comment">// 根据上面的分析，cache.get(chain.request()) = null</span></div><div class="line">        Response cacheCandidate = cache != <span class="keyword">null</span></div><div class="line">            ? cache.get(chain.request())</div><div class="line">            : <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</div><div class="line">		<span class="comment">// 这里我们就不贴代码了，CacheStrategy(networkRequest， cacheResponse=null)</span></div><div class="line">        CacheStrategy strategy = <span class="keyword">new</span> CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</div><div class="line">        Request networkRequest = strategy.networkRequest;</div><div class="line">        Response cacheResponse = strategy.cacheResponse;</div><div class="line">		...</div><div class="line">		<span class="comment">// 之前的逻辑都不是匹配我们现在这个缓存策略的。</span></div><div class="line">        Response networkResponse = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 所以我们之后要分析这个代码了</span></div><div class="line">            networkResponse = chain.proceed(networkRequest);</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们先看一下<code>cache.get(request.url)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Nullable</span> <span class="function">Response <span class="title">get</span><span class="params">(Request request)</span> </span>&#123;</div><div class="line">    <span class="comment">// cache依据url来生成key</span></div><div class="line">    String key = key(request.url());</div><div class="line">    DiskLruCache.Snapshot snapshot;</div><div class="line">    Entry entry;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 先来看看cache.get，目前的流程snapshot为空，所以直接返回null</span></div><div class="line">        snapshot = cache.get(key);</div><div class="line">        <span class="keyword">if</span> (snapshot == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里来看看<code>cache.get()</code>，感觉从这里的分析，感受到应该要尊重编译的流程，不然我大脑里也不知道某些变量某些列表是用来干嘛的，这样挺可怕的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DiskLruCache</span> <span class="keyword">implements</span> <span class="title">Closeable</span>, <span class="title">Flushable</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">      * Returns a snapshot of the entry named &#123;<span class="doctag">@code</span> key&#125;, or null if it doesn't exist is not currently</div><div class="line">      * readable. If a value is returned, it is moved to the head of the LRU queue.</div><div class="line">      */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Snapshot <span class="title">get</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="comment">// 这个方法是用来获得一个journalFile的，我直接在这里解释一下这个方法做了什么。</span></div><div class="line">        <span class="comment">// 我们在创建Cache的时候创建了一个File，这个方法是用来保存JournalFile的</span></div><div class="line">        <span class="comment">// 这个JournalFile就是用来保存缓存的。</span></div><div class="line">        initialize();</div><div class="line"></div><div class="line">        checkNotClosed();</div><div class="line">        validateKey(key);</div><div class="line">        <span class="comment">// 我们这次请求是第一次请求，所以lruEntries没有我们要的缓存。</span></div><div class="line">        Entry entry = lruEntries.get(key);</div><div class="line">        <span class="comment">// 因为entry = null 所以直接返回null了</span></div><div class="line">        <span class="keyword">if</span> (entry == <span class="keyword">null</span> || !entry.readable) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们来分析一下下一个Interceptor，ConnectInterceptor，好吧，ConnectInterceptor目前我还无法理解，他需要一些关于连接池的知识，可能关联到网络层的问题。之后我去别人博客看看关于这方面的东西</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line">  * Opens a connection to the target server and proceeds to the next interceptor. </div><div class="line">  * 打开与目标服务器的连接，然后继续执行下一个拦截器。</div><div class="line">  */</div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        RealInterceptorChain realChain = (RealInterceptorChain) chain;</div><div class="line">        Request request = realChain.request();</div><div class="line">        StreamAllocation streamAllocation = realChain.streamAllocation();</div><div class="line"></div><div class="line">        <span class="comment">// We need the network to satisfy this request. Possibly for validating a conditional GET.	  </span></div><div class="line">        <span class="keyword">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class="string">"GET"</span>);</div><div class="line">        HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);</div><div class="line">        RealConnection connection = streamAllocation.connection();</div><div class="line"></div><div class="line">        <span class="keyword">return</span> realChain.proceed(request, streamAllocation, httpCodec, connection);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来来看一下下一个Interceptor，NetworkInterceptor，这里的代码我们先放一放，因为我看的不是太懂，所以我们先去分析下一个Interceptor，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        Request request = chain.request();</div><div class="line"></div><div class="line">        <span class="comment">// Double-check the URL filter to prevent redirects from hitting filtered URLs.</span></div><div class="line">        <span class="keyword">if</span> (urlFilter != <span class="keyword">null</span>) &#123;</div><div class="line">            urlFilter.checkURLPermitted(request.url().url());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span> (lock) &#123;</div><div class="line">            connectPending = <span class="keyword">false</span>;</div><div class="line">            proxy = chain.connection().route().proxy();</div><div class="line">            handshake = chain.connection().handshake();</div><div class="line">            lock.notifyAll();</div><div class="line"></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">while</span> (!proceed) &#123;</div><div class="line">                    lock.wait(); <span class="comment">// Wait until proceed() is called.</span></div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                Thread.currentThread().interrupt(); <span class="comment">// Retain interrupted status.</span></div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedIOException();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Try to lock in the Content-Length before transmitting the request body.</span></div><div class="line">        <span class="keyword">if</span> (request.body() <span class="keyword">instanceof</span> OutputStreamRequestBody) &#123;</div><div class="line">            OutputStreamRequestBody requestBody = (OutputStreamRequestBody) request.body();</div><div class="line">            request = requestBody.prepareToSendRequest(request);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Response response = chain.proceed(request);</div><div class="line">		...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里是关于CallServerInterceptor的分析，所以到这里，我们的请求已经成功发送，也成功返回，之后我们来就要将response进行处理。所以我们要逆着去再走interceptor了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CallServerInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> forWebSocket;</div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        RealInterceptorChain realChain = (RealInterceptorChain) chain;</div><div class="line">        HttpCodec httpCodec = realChain.httpStream();</div><div class="line">        StreamAllocation streamAllocation = realChain.streamAllocation();</div><div class="line">        RealConnection connection = (RealConnection) realChain.connection();</div><div class="line">        Request request = realChain.request();</div><div class="line"></div><div class="line">        <span class="keyword">long</span> sentRequestMillis = System.currentTimeMillis();</div><div class="line"></div><div class="line">        realChain.eventListener().requestHeadersStart(realChain.call());</div><div class="line">        <span class="comment">// 这个方法是用来将header通过okio写的</span></div><div class="line">        httpCodec.writeRequestHeaders(request);</div><div class="line">        realChain.eventListener().requestHeadersEnd(realChain.call(), request);</div><div class="line"></div><div class="line">        Response.Builder responseBuilder = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// 之后这里是用来写body的，因为我们这个请求没有body，所以暂时不去考虑</span></div><div class="line">        <span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class="keyword">null</span>) &#123;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 将请求刷新到底层套接字并发出信号，不再传输字节。</span></div><div class="line">        <span class="comment">// 至此，我们请求已经成功发送完了.</span></div><div class="line">        httpCodec.finishRequest();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</div><div class="line">            realChain.eventListener().responseHeadersStart(realChain.call());</div><div class="line">           	<span class="comment">// 这里就是我们就是接收服务端的response的header了。</span></div><div class="line">            responseBuilder = httpCodec.readResponseHeaders(<span class="keyword">false</span>);</div><div class="line">        &#125;</div><div class="line">		<span class="comment">// 这个就是我们的response</span></div><div class="line">        Response response = responseBuilder</div><div class="line">            .request(request)</div><div class="line">            .handshake(streamAllocation.connection().handshake())</div><div class="line">            .sentRequestAtMillis(sentRequestMillis)</div><div class="line">            .receivedResponseAtMillis(System.currentTimeMillis())</div><div class="line">            .build();</div><div class="line"></div><div class="line">        <span class="keyword">int</span> code = response.code();</div><div class="line">        <span class="comment">// 判断response的code值，这里直接讲一下关于code的内容</span></div><div class="line">        <span class="comment">// 1xx: 表示通知信息的，如请求收到了或正在进行处理</span></div><div class="line">        <span class="comment">// 2xx: 表示成功，如接受或知道了。</span></div><div class="line">        <span class="comment">// 3xx: 表示重定向，如要完成请求还必须采取进一步的行动</span></div><div class="line">        <span class="comment">// 4xx: 表示客户端的差错，如请求中有错误的语法或不能完成</span></div><div class="line">        <span class="comment">// 5xx: 服务器的差错，如服务器失效无法完成请求。</span></div><div class="line">        <span class="keyword">if</span> (code == <span class="number">100</span>) &#123;</div><div class="line">            <span class="comment">// server sent a 100-continue even though we did not request one.</span></div><div class="line">            <span class="comment">// try again to read the actual response</span></div><div class="line">            responseBuilder = httpCodec.readResponseHeaders(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">            response = responseBuilder</div><div class="line">                .request(request)</div><div class="line">                .handshake(streamAllocation.connection().handshake())</div><div class="line">                .sentRequestAtMillis(sentRequestMillis)</div><div class="line">                .receivedResponseAtMillis(System.currentTimeMillis())</div><div class="line">                .build();</div><div class="line"></div><div class="line">            code = response.code();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        realChain.eventListener()</div><div class="line">            .responseHeadersEnd(realChain.call(), response);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (forWebSocket &amp;&amp; code == <span class="number">101</span>) &#123;</div><div class="line">            <span class="comment">// Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span></div><div class="line">            response = response.newBuilder()</div><div class="line">                .body(Util.EMPTY_RESPONSE)</div><div class="line">                .build();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            response = response.newBuilder()</div><div class="line">                .body(httpCodec.openResponseBody(response))</div><div class="line">                .build();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="string">"close"</span>.equalsIgnoreCase(response.request().header(<span class="string">"Connection"</span>))</div><div class="line">            || <span class="string">"close"</span>.equalsIgnoreCase(response.header(<span class="string">"Connection"</span>))) &#123;</div><div class="line">            streamAllocation.noNewStreams();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> ((code == <span class="number">204</span> || code == <span class="number">205</span>) &amp;&amp; response.body().contentLength() &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(</div><div class="line">                <span class="string">"HTTP "</span> + code + <span class="string">" had non-zero Content-Length: "</span> + response.body().contentLength());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> response;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以我们又回到了NetworkInterceptor，并且执行到<code>chain.proceed(request);</code>，我们再来看之后执行代码。这个NetworkInterceptor之后的工作只是将变量放入全局变量中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        ...</div><div class="line">        Response response = chain.proceed(request);</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span> (lock) &#123;</div><div class="line">            networkResponse = response;</div><div class="line">            url = response.request().url().url();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> response;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来的ConnectInterceptor并没有做任何之后的操作。所以我们可以直接看上面的CacheInterceptor。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        ...</div><div class="line">        <span class="comment">// 执行到这里，networkResponse 不为空，cacheResponse为空。</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            networkResponse = chain.proceed(networkRequest);</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (networkResponse == <span class="keyword">null</span> &amp;&amp; cacheCandidate != <span class="keyword">null</span>) &#123;</div><div class="line">                ...</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// If we have a cache response too, then we're doing a conditional get.</span></div><div class="line">        <span class="comment">// 因为cacheResponse为空，所以这里我们先不执行</span></div><div class="line">        <span class="keyword">if</span> (cacheResponse != <span class="keyword">null</span>) &#123;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// stripBody就是将Response的body剔除掉。</span></div><div class="line">        <span class="comment">// 所以这个Response就是一个没有body的response。</span></div><div class="line">        Response response = networkResponse.newBuilder()</div><div class="line">            .cacheResponse(stripBody(cacheResponse))</div><div class="line">            .networkResponse(stripBody(networkResponse))</div><div class="line">            .build();</div><div class="line"></div><div class="line">        <span class="comment">// 这个cache是我们在初始化OkhttpClient自己初始化的</span></div><div class="line">        <span class="comment">// 所以这里的cache不为空。</span></div><div class="line">        <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// 判断response是否有body并且判断这个response是否可以被缓存。</span></div><div class="line">            <span class="keyword">if</span> (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</div><div class="line">                <span class="comment">// Offer this request to the cache.</span></div><div class="line">                <span class="comment">// 这里很有意思，这个缓存的东西只会缓存GET请求。</span></div><div class="line">                <span class="comment">// 因为我们现在这个方法是GET请求，而且之前GET请求是没有body的</span></div><div class="line">                <span class="comment">// 所以这里我们这里判断是可以缓存了。</span></div><div class="line">                CacheRequest cacheRequest = cache.put(response);</div><div class="line">                ...</div><div class="line">            &#125;</div><div class="line">			...</div><div class="line">        &#125;</div><div class="line">		...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们要分析一下<code>cache.put(response);</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Cache</span> <span class="keyword">implements</span> <span class="title">Closeable</span>, <span class="title">Flushable</span> </span>&#123;</div><div class="line">    <span class="meta">@Nullable</span> <span class="function">CacheRequest <span class="title">put</span><span class="params">(Response response)</span> </span>&#123;</div><div class="line">        <span class="comment">// 前面的代码就是判断这个请求是否可以加入到cache。</span></div><div class="line">        <span class="comment">// 所以我们直接分析下面的代码</span></div><div class="line">		...</div><div class="line">            </div><div class="line">        Entry entry = <span class="keyword">new</span> Entry(response);</div><div class="line">        DiskLruCache.Editor editor = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 这里我们要看一下关于这个edit</span></div><div class="line">            editor = cache.edit(key(response.request().url()));</div><div class="line">            ...</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们看一下关于<code>cache.edit(key(response.request().url()));</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">  * Returns an editor for the entry named &#123;<span class="doctag">@code</span> key&#125;, or null if another edit is in progress.</div><div class="line">  * 返回名为&#123;<span class="doctag">@code</span> key&#125;的条目的编辑器，如果正在进行其他编辑，则返回null。</div><div class="line">  */</div><div class="line"><span class="keyword">public</span> <span class="meta">@Nullable</span> <span class="function">Editor <span class="title">edit</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="comment">// ANY_SEQUENCE_NUMBER = -1;</span></div><div class="line">    <span class="keyword">return</span> edit(key, ANY_SEQUENCE_NUMBER);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">synchronized</span> Editor <span class="title">edit</span><span class="params">(String key, <span class="keyword">long</span> expectedSequenceNumber)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="comment">// 这个方法还是用来初始化JournalFile</span></div><div class="line">    initialize();</div><div class="line"></div><div class="line">    checkNotClosed();</div><div class="line">    validateKey(key);</div><div class="line">    </div><div class="line">    <span class="comment">// lruEntries是一个LinkedHashMap</span></div><div class="line">    Entry entry = lruEntries.get(key);</div><div class="line">    ...</div><div class="line">        </div><div class="line">    <span class="comment">// Flush the journal before creating files to prevent file leaks.</span></div><div class="line">    <span class="comment">// 在创建文件之前刷新日志以防止文件泄漏。</span></div><div class="line">    journalWriter.writeUtf8(DIRTY).writeByte(<span class="string">' '</span>).writeUtf8(key).writeByte(<span class="string">'\n'</span>);</div><div class="line">    journalWriter.flush();</div><div class="line">	...</div><div class="line"></div><div class="line">    <span class="comment">// 如果entry为空的话，创建一个entry，并放入到lruEntries</span></div><div class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</div><div class="line">        entry = <span class="keyword">new</span> Entry(key);</div><div class="line">        lruEntries.put(key, entry);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 这里再创建了一个Editor并返回</span></div><div class="line">    Editor editor = <span class="keyword">new</span> Editor(entry);</div><div class="line">    entry.currentEditor = editor;</div><div class="line">    <span class="keyword">return</span> editor;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之后我们再返回到<code>cache.put(response);</code>，到了最后Cache返回了CacheRequestImpl。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Cache</span> <span class="keyword">implements</span> <span class="title">Closeable</span>, <span class="title">Flushable</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="meta">@Nullable</span> <span class="function">CacheRequest <span class="title">put</span><span class="params">(Response response)</span> </span>&#123;</div><div class="line">        ...</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            editor = cache.edit(key(response.request().url()));</div><div class="line">            <span class="keyword">if</span> (editor == <span class="keyword">null</span>) &#123;</div><div class="line">                 <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">            entry.writeTo(editor);</div><div class="line">            <span class="comment">// 这里只是做了一些初始化的操作</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CacheRequestImpl(editor);</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之后再回到<code>CacheInterceptor.intercept()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</div><div class="line">                <span class="comment">// Offer this request to the cache.</span></div><div class="line">                CacheRequest cacheRequest = cache.put(response);</div><div class="line">               	<span class="comment">// 这里我们返回了一个新的response。</span></div><div class="line">                <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    cache.remove(networkRequest);</div><div class="line">                &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</div><div class="line">                    <span class="comment">// The cache cannot be written.</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> response;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之后我们再看上一层的Interceptor，BridgeInterceptor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BridgeInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        Response networkResponse = chain.proceed(requestBuilder.build());</div><div class="line">		<span class="comment">// </span></div><div class="line">        HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());</div><div class="line"></div><div class="line">        Response.Builder responseBuilder = networkResponse.newBuilder()</div><div class="line">            .request(userRequest);</div><div class="line"></div><div class="line">        <span class="comment">// 因为我们的请求里面没有body，所以不用走这个请求。</span></div><div class="line">        <span class="keyword">if</span> (transparentGzip</div><div class="line">            &amp;&amp; <span class="string">"gzip"</span>.equalsIgnoreCase(networkResponse.header(<span class="string">"Content-Encoding"</span>))</div><div class="line">            &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 所以直接返回新建的response</span></div><div class="line">        <span class="keyword">return</span> responseBuilder.build();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后再回去看<code>RetryAndFollowUpInterceptor.interceptor</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryAndFollowUpInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">		...</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            ...</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                response = realChain.proceed(request, streamAllocation, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">                releaseConnection = <span class="keyword">false</span>;</div><div class="line">            &#125; <span class="keyword">catch</span> (RouteException e) &#123;</div><div class="line">                ...</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                ...</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                <span class="comment">// We're throwing an unchecked exception. Release any resources.</span></div><div class="line">                <span class="comment">// releaseConnection = false</span></div><div class="line">                <span class="keyword">if</span> (releaseConnection) &#123;</div><div class="line">                    streamAllocation.streamFailed(<span class="keyword">null</span>);</div><div class="line">                    streamAllocation.release();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Attach the prior response if it exists. Such responses never have a body.</span></div><div class="line">            <span class="comment">// priorResponse = null</span></div><div class="line">            <span class="keyword">if</span> (priorResponse != <span class="keyword">null</span>) &#123;</div><div class="line">                ...</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            Request followUp;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// 这个方法就是处理异常情况下的request。</span></div><div class="line">                followUp = followUpRequest(response, streamAllocation.route());</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                streamAllocation.release();</div><div class="line">                <span class="keyword">throw</span> e;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 正常的请求，到这里就结束了。</span></div><div class="line">            <span class="keyword">if</span> (followUp == <span class="keyword">null</span>) &#123;</div><div class="line">                streamAllocation.release();</div><div class="line">                <span class="keyword">return</span> response;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            closeQuietly(response.body());</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</div><div class="line">                streamAllocation.release();</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">"Too many follow-up requests: "</span> + followUpCount);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (followUp.body() <span class="keyword">instanceof</span> UnrepeatableRequestBody) &#123;</div><div class="line">                streamAllocation.release();</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> HttpRetryException(<span class="string">"Cannot retry streamed HTTP body"</span>, response.code());</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (!sameConnection(response, followUp.url())) &#123;</div><div class="line">                streamAllocation.release();</div><div class="line">                streamAllocation = <span class="keyword">new</span> StreamAllocation(client.connectionPool(),</div><div class="line">                                                        createAddress(followUp.url()), call, eventListener, callStackTrace);</div><div class="line">                <span class="keyword">this</span>.streamAllocation = streamAllocation;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (streamAllocation.codec() != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Closing the body of "</span> + response</div><div class="line">                                                + <span class="string">" didn't close its backing stream. Bad interceptor?"</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            request = followUp;</div><div class="line">            priorResponse = response;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
      
    </div>
    <footer class="article-footer">
      <ul class="article-meta">
        <li>
          <span class="label">Published Date:</span>
          <a href="/2019/02/01/okhttp/" class="article-date">
  <time datetime="2019-02-01T01:45:21.000Z" itemprop="datePublished">2019-02-01</time>
</a>

        </li>
        
        
          <li>
            <span class="label">Tag:</span>
            
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li></ul>


          </li>
        
        <hr/>
      </ul>
    </footer>
  </div>
  
    
<nav id="article-nav" class="article-nav">
  
    <a href="/2019/02/11/三数之和/" id="article-nav-newer" class="article-nav-link-wrap newer">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          三数之和
        
      </div>
    </a>
  
  
    <a href="/2019/01/29/缺失数字/" id="article-nav-older" class="article-nav-link-wrap older">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">缺失数字</div>
    </a>
  
</nav>


  
</article>










      </div>
      
    <footer id="footer" class="post-footer footer">
      
        <ul class="footer-links">
          
            <li><a href="/archives/"><span class="fa fa-book"></span></a></li>
          
            <li><a href="https://github.com/chanchangxing"><span class="fa fa-globe"></span></a></li>
          
        </ul>
	    
      <hr/>
      <div id="footerContent" class="footer-content">
        <p>这篇写完就删站</p>


      </div>
    </footer>

      







<script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>


  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>


<script src="/js/typing.js"></script>
<!--[if lt IE 9]><script src="https://cdn.jsdelivr.net/npm/html5shiv@3/dist/html5shiv.min.js"></script><![endif]-->







    </div>
  </body>
</html>
